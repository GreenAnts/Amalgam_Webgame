// ui/BoardRenderer.js - Tea House Aesthetic (Transparent Background)
import {
    GRID_SIZE,
    createBoardDict,
    createGoldenConnectionsSet,
    GOLDEN_LINES_DICT
} from '../core/Constants.js';

export class BoardRenderer {
    constructor(ctx, canvas) {
        this.ctx = ctx;
        this.canvas = canvas;

        this.boardDict = createBoardDict();
        this.goldenConnections = createGoldenConnectionsSet();

        // Tea House Palette - Strictly flat colors with no background fill
        this.colors = {
            ink: '#7a6d60',
            inkFaint: 'rgba(122, 109, 96, 0.3)',
            waxSeal: '#8a622a',
            stain1: '#d5c2ac',
            stain2: '#b4aaa0',
            stain3: '#a09682',
            // Added from SetupUI theme
            paperTop: '#fdfaf5',
            paperBottom: '#f3eadf',
            // Added from SetupUI theme
            boardMatInner: '#fdfaf5',
            boardMatOuter: '#f3eadf',
            border: '#d6c6b2'
        };

        // Offscreen shadow cache
        this.shadowCanvas = document.createElement('canvas');
        this.shadowCtx = this.shadowCanvas.getContext('2d');

        this.updateCanvasSize();
        this.rebuildShadowCache();
    }

    updateCanvasSize() {
        const padding = 60;
        const availableSize = Math.min(this.canvas.width, this.canvas.height) - (padding * 2);
        const boardSpan = 24;

        this.scale = availableSize / boardSpan;
        this.originX = this.canvas.width / 2;
        this.originY = this.canvas.height / 2;

        // If canvas size changed, shadow cache must be rebuilt
        if (
            this.shadowCanvas.width !== this.canvas.width ||
            this.shadowCanvas.height !== this.canvas.height
        ) {
            this.shadowCanvas.width = this.canvas.width;
            this.shadowCanvas.height = this.canvas.height;
            this.rebuildShadowCache();
        }
    }

    // FIX: Re-adding the missing getOrigin method
    getOrigin() {
        return { originX: this.originX, originY: this.originY };
    }

    // New method: Draws the SetupUI-themed circular background "Mat"
    drawBoardBackground() {
        // The radius includes the .75 cell width buffer
        const radius = (12 + 0.75) * this.scale;

        this.ctx.save();
        
        // 1. DYNAMIC OUTER SHADOW
        // We ensure the shadow is generated by the CIRCLE, not the polygons
        this.ctx.shadowColor = 'rgba(60, 50, 40, 0.3)';
        this.ctx.shadowBlur = 20 * (this.scale / 45); // Blur extends from the edge of the radius
        this.ctx.shadowOffsetX = 0;
        this.ctx.shadowOffsetY = 6 * (this.scale / 45); // Slight downward "lift"

        // 2. GRADIENT FILL
        const grad = this.ctx.createRadialGradient(
            this.originX, this.originY, 0,
            this.originX, this.originY, radius + 15
        );
        grad.addColorStop(0, this.colors.boardMatInner);
        grad.addColorStop(1, this.colors.boardMatOuter);
        
        this.ctx.fillStyle = grad;
        this.ctx.beginPath();
        this.ctx.arc(this.originX, this.originY, radius , 0, Math.PI * 2);
        this.ctx.fill();

        // 3. BORDER (Cleanup shadow first so the border doesn't look "fuzzy")
        this.ctx.shadowColor = 'transparent';
        this.ctx.strokeStyle = this.colors.border;
        this.ctx.lineWidth = 4 * (this.scale / 45);
        this.ctx.stroke();

        this.ctx.restore();
    }

    /* ===========================
       SHADOW CACHE
    =========================== */

    rebuildShadowCache() {
        const sctx = this.shadowCtx;
        sctx.clearRect(0, 0, this.shadowCanvas.width, this.shadowCanvas.height);

        sctx.save();
        // No shadow here! This ensures the board patterns look like 
        // they are stained/inked INTO the paper mat.
        this.drawPolygons(sctx);
        sctx.restore();
    }

    /* ===========================
       POLYGONS
    =========================== */

    drawPolygons(ctxOverride = null) {
        const ctx = ctxOverride ?? this.ctx;

        const polygonsToDraw1 = [
            [{x: 0, y: 12}, {x: 5, y: 11}, {x: 0, y: 6}],
            [{x: 0, y: 12}, {x: -5, y: 11}, {x: 0, y: 6}],
            [{x: 5, y: 11}, {x: 8, y: 9}, {x: 6, y: 6}, {x: 0, y: 6}],
            [{x: -5, y: 11}, {x: -8, y: 9}, {x: -6, y: 6}, {x: 0, y: 6}],
            [{x: 0, y: -12}, {x: 5, y: -11}, {x: 0, y: -6}],
            [{x: 0, y: -12}, {x: -5, y: -11}, {x: 0, y: -6}],
            [{x: -5, y: -11}, {x: -8, y: -9}, {x: -6, y: -6}, {x: 0, y: -6}],
            [{x: 5, y: -11}, {x: 8, y: -9}, {x: 6, y: -6}, {x: 0, y: -6}]
        ];

        const polygonsToDraw2 = [
            [{x: 0, y: 6}, {x: 6, y: 6}, {x: 6, y: 0}],
            [{x: 0, y: 6}, {x: -6, y: 6}, {x: -6, y: 0}],
            [{x: 0, y: -6}, {x: -6, y: -6}, {x: -6, y: 0}],
            [{x: 0, y: -6}, {x: 6, y: -6}, {x: 6, y: 0}],
            [{x: 12, y: 0}, {x: 11, y: 5}, {x: 9, y: 8}, {x: 8, y: 3}],
            [{x: -12, y: 0}, {x: -11, y: 5}, {x: -9, y: 8}, {x: -8, y: 3}],
            [{x: -12, y: 0}, {x: -11, y: -5}, {x: -9, y: -8}, {x: -8, y: -3}],
            [{x: 12, y: 0}, {x: 11, y: -5}, {x: 9, y: -8}, {x: 8, y: -3}],
            [{x: 6, y: 6}, {x: 8, y: 9}, {x: 9, y: 8}],
            [{x: -6, y: 6}, {x: -8, y: 9}, {x: -9, y: 8}],
            [{x: -6, y: -6}, {x: -8, y: -9}, {x: -9, y: -8}],
            [{x: 6, y: -6}, {x: 8, y: -9}, {x: 9, y: -8}]
        ];

        const polygonsToDraw3 = [
            [{x: 0, y: 0}, {x: 6, y: 0}, {x: 0, y: 6}],
            [{x: 0, y: 0}, {x: -6, y: 0}, {x: 0, y: 6}],
            [{x: 0, y: 0}, {x: -6, y: 0}, {x: 0, y: -6}],
            [{x: 0, y: 0}, {x: 6, y: 0}, {x: 0, y: -6}],
            [{x: 6, y: 0}, {x: 6, y: 6}, {x: 9, y: 8}, {x: 8, y: 3}, {x: 12, y: 0}],
            [{x: -6, y: 0}, {x: -6, y: 6}, {x: -9, y: 8}, {x: -8, y: 3}, {x: -12, y: 0}],
            [{x: -6, y: 0}, {x: -6, y: -6}, {x: -9, y: -8}, {x: -8, y: -3}, {x: -12, y: 0}],
            [{x: 6, y: 0}, {x: 6, y: -6}, {x: 9, y: -8}, {x: 8, y: -3}, {x: 12, y: 0}]
        ];

        const drawSet = (polygons, fill) => {
            ctx.fillStyle = fill;
            polygons.forEach(points => {
                ctx.beginPath();
                ctx.moveTo(
                    this.originX + points[0].x * this.scale,
                    this.originY - points[0].y * this.scale
                );
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(
                        this.originX + points[i].x * this.scale,
                        this.originY - points[i].y * this.scale
                    );
                }
                ctx.closePath();
                ctx.fill();
            });
        };

        drawSet(polygonsToDraw1, this.colors.stain1);
        drawSet(polygonsToDraw2, this.colors.stain2);
        drawSet(polygonsToDraw3, this.colors.stain3);
    }

    drawLines() {
        const inkLineColor = this.colors.ink;
        const goldenLineColor = this.colors.waxSeal;

        this.ctx.save();
        this.ctx.lineCap = 'round';
        this.ctx.strokeStyle = inkLineColor;
        this.ctx.lineWidth = 1.0 * (this.scale / 45);
        this.ctx.globalAlpha = 0.07;

        for (const coordStr in this.boardDict) {
            const [x, y] = coordStr.split(',').map(Number);
            const startX = this.originX + x * this.scale;
            const startY = this.originY - y * this.scale;

            const h = `${x + 1},${y}`;
            if (this.boardDict[h] !== undefined) {
                const key = `${Math.min(x, x + 1)},${y}-${Math.max(x, x + 1)},${y}`;
                if (!this.goldenConnections.has(key)) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, startY);
                    this.ctx.lineTo(this.originX + (x + 1) * this.scale, startY);
                    this.ctx.stroke();
                }
            }

            const v = `${x},${y + 1}`;
            if (this.boardDict[v] !== undefined) {
                const key = `${x},${Math.min(y, y + 1)}-${x},${Math.max(y, y + 1)}`;
                if (!this.goldenConnections.has(key)) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, startY);
                    this.ctx.lineTo(startX, this.originY - (y + 1) * this.scale);
                    this.ctx.stroke();
                }
            }
        }

        this.ctx.strokeStyle = goldenLineColor;
        this.ctx.lineWidth = 2.5 * (this.scale / 45);
        this.ctx.globalAlpha = 1.0;

        for (const coordStr in GOLDEN_LINES_DICT) {
            const [x, y] = coordStr.split(',').map(Number);
            const startX = this.originX + x * this.scale;
            const startY = this.originY - y * this.scale;

            GOLDEN_LINES_DICT[coordStr].forEach(t => {
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(
                    this.originX + t.x * this.scale,
                    this.originY - t.y * this.scale
                );
                this.ctx.stroke();
            });
        }

        this.ctx.restore();
    }

    drawIntersections() {
        const scaleFactor = this.scale / 50;
        const goldenRadius = 4.5 * scaleFactor;
        const diamondSize = 3.5 * scaleFactor;

        for (const coordStr in this.boardDict) {
            const type = this.boardDict[coordStr];
            const [x, y] = coordStr.split(',').map(Number);
            const px = this.originX + x * this.scale;
            const py = this.originY - y * this.scale;

            this.ctx.fillStyle = type === 'golden'
                ? this.colors.waxSeal
                : this.colors.ink;

            this.ctx.beginPath();
            if (type === 'golden') {
                this.ctx.arc(px, py, goldenRadius, 0, Math.PI * 2);
            } else {
                this.ctx.moveTo(px, py - diamondSize);
                this.ctx.lineTo(px + diamondSize, py);
                this.ctx.lineTo(px, py + diamondSize);
                this.ctx.lineTo(px - diamondSize, py);
                this.ctx.closePath();
            }
            this.ctx.fill();
        }
    }

    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    render() {
        this.updateCanvasSize();
        this.clear();

        // Step 1: Draw the Mat + its Outer Shadow
        this.drawBoardBackground();

        // Step 2: Draw the flat board patterns on top of the Mat
        this.ctx.drawImage(this.shadowCanvas, 0, 0);

        // Step 3: Draw Lines and Intersections
        this.drawLines();
        this.drawIntersections();
    }
}
